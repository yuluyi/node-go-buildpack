#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-dir>

set -e
set -o pipefail   # dont ignore exit codes when piping output
set -o nounset    # fail on unset variables
unset GIT_DIR     # Avoid GIT_DIR leak from previous build steps

### Constants

DEFAULT_CACHE="node_modules bower_components"

### Configure directories

BUILD_DIR=${1:-}
CACHE_DIR=${2:-}
ENV_DIR=${3:-}
BP_DIR=$(cd $(dirname ${0:-}); cd ..; pwd)
$BP_DIR/compile-extensions/bin/check_stack_support

mkdir -p "$BUILD_DIR/.heroku/node/"
cd $BUILD_DIR
export PATH="$BUILD_DIR/.heroku/node/bin":$PATH

# CF Common
export BUILDPACK_PATH=$BP_DIR
source $BP_DIR/compile-extensions/lib/common
# END CF Common
LOG_FILE='/tmp/node-build-log.txt'
echo "" > "$LOG_FILE"

### Load dependencies

source $BP_DIR/lib/output.sh
source $BP_DIR/lib/json.sh
source $BP_DIR/lib/failure.sh
source $BP_DIR/lib/environment.sh
source $BP_DIR/lib/binaries.sh
source $BP_DIR/lib/cache.sh
source $BP_DIR/lib/dependencies.sh
source $BP_DIR/lib/vendor/new_relic/install.sh $BUILD_DIR

### Handle errors

handle_failure() {
  header "Build failed"
  warn_untracked_dependencies "$LOG_FILE"
  warn_angular_resolution "$LOG_FILE"
  warn_missing_devdeps "$LOG_FILE"
  warn_econnreset "$LOG_FILE"
  failure_message | output "$LOG_FILE"
}
trap 'handle_failure' ERR

### Check initial state

[ -e "$BUILD_DIR/node_modules" ] && PREBUILD=true || PREBUILD=false

### Failures that should be caught immediately

fail_invalid_package_json "$BUILD_DIR"
warn_prebuilt_modules "$BUILD_DIR"
warn_missing_package_json "$BUILD_DIR"

### Compile

create_env() {
  write_profile "$BP_DIR" "$BUILD_DIR"
  export_env_dir "$ENV_DIR"
  create_default_env
}

header "Creating runtime environment"
create_env # can't pipe the whole thing because piping causes subshells, preventing exports
list_node_config | output "$LOG_FILE"

install_bins() {
  local node_engine=$(read_json "$BUILD_DIR/package.json" ".engines.node")
  local iojs_engine=$(read_json "$BUILD_DIR/package.json" ".engines.iojs")
  local npm_engine=$(read_json "$BUILD_DIR/package.json" ".engines.npm")

  if [ -n "$iojs_engine" ]; then
    echo "engines.iojs (package.json):  $iojs_engine (iojs)"
  else
    echo "engines.node (package.json):  ${node_engine:-unspecified}"
  fi
  echo "engines.npm (package.json):   ${npm_engine:-unspecified (use default)}"
  echo ""

  if [ -n "$iojs_engine" ]; then
    warn_node_engine "$iojs_engine"
    install_iojs "$iojs_engine" "$BUILD_DIR/.heroku/node"
    echo "Using bundled npm version for iojs compatibility: `npm --version`"
  else
    warn_node_engine "$node_engine"
    install_nodejs "$node_engine" "$BUILD_DIR/.heroku/node"
    install_npm "$npm_engine" "$BUILD_DIR/.heroku/node"
  fi
}

header "Installing binaries"
install_bins | output "$LOG_FILE"

restore_cache() {
  local cache_status="$(get_cache_status)"

  if [ "$cache_status" == "valid" ]; then
    local cache_directories=$(get_cache_directories)
    if [ "$cache_directories" == "" ]; then
      echo "Loading 2 from cacheDirectories (default):"
      restore_cache_directories "$BUILD_DIR" "$CACHE_DIR" "$DEFAULT_CACHE"
    else
      echo "Loading $(echo $cache_directories | wc -w | xargs) from cacheDirectories (package.json):"
      restore_cache_directories "$BUILD_DIR" "$CACHE_DIR" $cache_directories
    fi
  else
    echo "Skipping cache restore ($cache_status)"
  fi
}

header "Restoring cache"
restore_cache | output "$LOG_FILE"

build_dependencies() {
  if $PREBUILD; then
    echo "Prebuild detected (node_modules already exists)"
    rebuild_node_modules "$BUILD_DIR"
  else
    install_node_modules "$BUILD_DIR"
  fi
}

header "Building dependencies"
build_dependencies | output "$LOG_FILE"

cache_build() {
  local cache_directories=$(get_cache_directories)

  echo "Clearing previous node cache"
  clear_cache
  if ! ${NODE_MODULES_CACHE:-true}; then
    echo "Skipping cache save (disabled by config)"
  elif [ "$cache_directories" == "" ]; then
    echo "Saving 2 cacheDirectories (default):"
    save_cache_directories "$BUILD_DIR" "$CACHE_DIR" "$DEFAULT_CACHE"
  else
    echo "Saving $(echo $cache_directories | wc -w | xargs) cacheDirectories (package.json):"
    save_cache_directories "$BUILD_DIR" "$CACHE_DIR" $cache_directories
  fi
  save_signature
}

header "Caching build"
cache_build | output "$LOG_FILE"

summarize_build() {
  cd $BUILD_DIR
  (npm ls --depth=0 | tail -n +2 || true) 2>/dev/null
}

header "Build succeeded!"
summarize_build | output "$LOG_FILE"

warn_no_start "$LOG_FILE"
warn_unmet_dep "$LOG_FILE"

set -eo pipefail

mkdir -p "$1" "$2"
build=$(cd "$1/" && pwd)
cache=$(cd "$2/" && pwd)
env_dir="${3}"
buildpack=$(cd "$(dirname $0)/.." && pwd)
arch=$(uname -m|tr A-Z a-z)
if test $arch = x86_64
then arch=amd64
fi
plat=$(uname|tr A-Z a-z)-$arch
PATH=$buildpack/$plat/bin:$PATH

steptxt="----->"
YELLOW='\033[1;33m'
RED='\033[1;31m'
NC='\033[0m' # No Color
CURL="curl -s -L --retry 15 --retry-delay 2" # retry for up to 30 seconds

default_go_version="$($buildpack/compile-extensions/bin/default_version_for $buildpack/manifest.yml go)"
DefaultGoVersion="go${default_go_version}"
TOOL=""

# CF Common
BUILDPACK_PATH=$buildpack
export BUILDPACK_PATH
source $buildpack/compile-extensions/lib/common
$BUILDPACK_PATH/compile-extensions/bin/check_stack_support
$BUILDPACK_PATH/compile-extensions/bin/download_dependency godep /tmp
tar -xzf /tmp/godep -C /tmp
$BUILDPACK_PATH/compile-extensions/bin/download_dependency glide /tmp
tar -xzf /tmp/glide -C /tmp
PATH=/tmp/bin:$PATH
# END CF Common

handleDefaultPkgSpec() {
    if [ "$pkgs" = "default" ];
    then
        warn "Installing package '.' (default)"
        pkgs="."
    fi
}

massagePkgSpecForVendor() {
    local t=""
    for pkg in $(echo $pkgs); do
      if [ "${pkg:0:1}" = "." ] || [ ! -d "./vendor/$pkg" ]; then
        t+="${pkg} "
      else
        t+="${name}/vendor/${pkg} "
      fi
    done
    pkgs="${t}"
}

# Go releases have moved to a new URL scheme
# starting with Go version 1.2.2. Return the old
# location for known old versions and the new
# location otherwise.
urlFor() {
    ver=$1
    file=$2
    case $ver in
    go1.0*|go1.1beta*|go1.1rc*|go1.1|go1.1.*|go1.2beta*|go1.2rc*|go1.2|go1.2.1)
        echo https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/go/$file
        ;;
    *)
        echo https://storage.googleapis.com/golang/$file
        ;;
    esac
}

# Expand to supported versions of Go, (e.g. expand "go1.5" to latest release go1.5.2)
# All specific or other versions, take as is.
expandVer() {
  buildpack_dir=$1
  target_version=$2
  highest_ver="$($buildpack_dir/compile-extensions/bin/highest_version $buildpack_dir/manifest.yml go $target_version)"

  if [ "$highest_ver" = "" ]; then
    echo $target_version
  else
    echo $highest_ver
  fi
}

# Report deprecated versions to user
# Use after expandVer
reportVer() {
  : # unsupported versions in Cloud Foundry will fail to push; no deprecation warnings needed
}

warnGoVersionOverride() {
  if test ! -z "${GOVERSION}"
  then
    warn "Using \$GOVERSION override."
    warn "     \$GOVERSION = ${GOVERSION}"
    warn ""
    warn "If this isn't what you want please run:'"
    warn "  cf unset-env <app> GOVERSION"
    warn ""
  fi
}

warnPackageSpecOverride() {
  if test ! -z "${GO_INSTALL_PACKAGE_SPEC}"
  then
    warn "Using \$GO_INSTALL_PACKAGE_SPEC override."
    warn "     \$GO_INSTALL_PACKAGE_SPEC = ${GO_INSTALL_PACKAGE_SPEC}"
    warn ""
    warn "If this isn't what you want please run:'"
    warn "  cf unset-env <app> GO_INSTALL_PACKAGE_SPEC"
    warn ""
  fi
}

# Sets up GOPATH (and posibly other GO* env vars) and returns the location of
# the source code as $src. The output of this function is meant to be eval'd'
setupGOPATH() {
    local name="${1}"
    local t="$(mktemp -d)"

    if test "${GO_SETUP_GOPATH_IN_IMAGE}" = "true"
    then
        mv -t ${t} ${build}/*
        GOPATH="${build}"
    else
        cp -R ${build}/* ${t}
        GOPATH="${t}/.go"
        echo export GOBIN="${build}/bin"
    fi

    local src="${GOPATH}/src/${name}"
    mkdir -p "${src}"
    mv -t "${src}" "${t}"/*

    echo "GOPATH=${GOPATH}"
    echo "src=${src}"
}

source "${buildpack}/lib/common.sh"
loadEnvDir "${env_dir}"
determineTool

ver=$(expandVer $buildpack $ver)
file=${GOFILE:-$ver.linux-amd64.tar.gz}
url=${GOURL:-$(urlFor $ver $file)}

if test -e $build/bin && ! test -d $build/bin
then
    err ""
    err "File bin exists and is not a directory."
    err ""
    exit 1
fi

reportVer $ver

if test -d "${cache}/${ver}/go"
then
    step "Using ${ver}"
else
    rm -rf ${cache}/* # be sure not to build up cruft
    mkdir -p "${cache}/${ver}"
    cd "${cache}/${ver}"
       exit_code=0

      filtered_url=$($BUILDPACK_PATH/compile-extensions/bin/download_dependency $ver $PWD) || exit_code=$?
      if [ $exit_code -ne 0 ]; then
        echo -e "`$buildpack/compile-extensions/bin/recommend_dependency $ver`" 1>&2
        exit 22
      fi

      start "Installing ${ver}"
        tar zxf $ver
        rm $ver
      finished

      echo "Downloaded [$filtered_url]"
    cd - >/dev/null
fi

mkdir -p $build/bin
export GOROOT="${cache}/${ver}/go"
PATH="${PATH}:${GOROOT}/bin"

# If $GO_LINKER_SYMBOL and GO_LINKER_VALUE are set, tell the linker to DTRT
FLAGS=(-tags cloudfoundry)
if [ -n "${GO_LINKER_SYMBOL}" -a -n "${GO_LINKER_VALUE}" ]
then
    case $ver in
    go1.5*|go1.6*)
        xval="${GO_LINKER_SYMBOL}=${GO_LINKER_VALUE}"
        ;;
    *)
        xval="${GO_LINKER_SYMBOL} ${GO_LINKER_VALUE}"
        ;;
    esac
    FLAGS+=(-ldflags "-X ${xval}")
fi

export GOPATH

case ${TOOL} in
    godep)
        eval "$(setupGOPATH ${name})"
        godepsJSON="${src}/Godeps/Godeps.json"

        pkgs=${GO_INSTALL_PACKAGE_SPEC:-$(<${godepsJSON} jq -r 'if .Packages then .Packages | join(" ") else "default" end')}
        warnPackageSpecOverride
        handleDefaultPkgSpec

        case $ver in
        go1.5*)
            if test "$GO15VENDOREXPERIMENT" = "1"
            then
                warn ""
                warn "\$GO15VENDOREXPERIMENT=1. This is an experiment. Things may not work as expected."
                warn "See https://docs.cloudfoundry.org/buildpacks/go/index.html#go%201.5 for more info."
                warn ""
               VendorExperiment="true"
            fi
        ;;
        go1.6*)
            if test "$GO15VENDOREXPERIMENT" = "0" || test -d "${src}/Godeps/_workspace/src"
            then
                VendorExperiment="false"
            else
                VendorExperiment="true"
            fi
            FLAGS+=(--buildmode=pie)
        ;;
        go1.7*)
          if test -n "$GO15VENDOREXPERIMENT"
          then
            err ""
            err "GO15VENDOREXPERIMENT is set, but is not supported by go1.7"
            err "run `cf unset-env <app> GO15VENDOREXPERIMENT`"
            err "before pushing again."
            err ""
            exit 1
          fi
          VendorExperiment="true"
        ;;
        *)
            VendorExperiment="false"
        ;;
        esac

        unset GIT_DIR # unset git dir or it will mess with goinstall
        cd "${src}"
        if test "$VendorExperiment" = "true"
        then
            if test ! -d "$build/vendor"
            then
              warn ""
              warn "vendor/ directory does not exist."
              warn ""
            fi
            massagePkgSpecForVendor
            step "Running: go install -v ${FLAGS[@]} ${pkgs}"
            go install -v "${FLAGS[@]}" ${pkgs} 2>&1
        else
            step "Running: godep go install -v ${FLAGS[@]} ${pkgs}"
            godep go install -v "${FLAGS[@]}" ${pkgs} 2>&1
        fi
    ;;
    go_nativevendoring)
        eval "$(setupGOPATH ${name})"

        pkgs=${GO_INSTALL_PACKAGE_SPEC-"default"}
        handleDefaultPkgSpec

        case $ver in
        go1.5*)
            if ! test "$GO15VENDOREXPERIMENT" = "1"
            then
                warn ""
                warn "\$GO15VENDOREXPERIMENT is not =1. To use vendor your packages in vendor/"
                warn "for go 1.5 this environment variable must be set to 1."
                warn ""
                exit 1
            fi
        ;;
        go1.6*)
            if test "$GO15VENDOREXPERIMENT" = "0"
            then
                warn ""
                warn "\$GO15VENDOREXPERIMENT=0. To use vendor your packages in vendor/"
                warn "for go 1.6 this environment variable must unset or set to 1."
                warn ""
                exit 1
            fi
        ;;
        esac

        unset GIT_DIR # unset git dir or it will mess with goinstall
        cd "${src}"

        massagePkgSpecForVendor

        step "Running: go install -v ${FLAGS[@]} ${pkgs}"
        go install -v "${FLAGS[@]}" ${pkgs} 2>&1
    ;;
    glide)
        # Do this before setupGOPATH as we need ${name} set first
        cd "${build}"
        name=$(glide name 2>/dev/null)

        eval "$(setupGOPATH ${name})"

        pkgs=${GO_INSTALL_PACKAGE_SPEC:-"default"}
        handleDefaultPkgSpec

        unset GIT_DIR
        cd "${src}"

        number_of_vendor_subdirectories=0
        if [ -d "vendor" ]; then
          number_of_vendor_subdirectories=$(find vendor -mindepth 1 -maxdepth 1 -type d | wc -l)
        fi

        if [ "$number_of_vendor_subdirectories" -eq 0 ]
        then
            step "Fetching any unsaved dependencies (glide install)"
            glide install 2>&1
        else
            step "Note: skipping (glide install) due to non-empty vendor directory."
        fi

        massagePkgSpecForVendor

        step "Running: go install -v ${FLAGS[@]} ${pkgs}"
        go install -v "${FLAGS[@]}" ${pkgs} 2>&1
    ;;
# GB installation currently unsupported
    gb)
        warn ""
        warn "Error: Cloud Foundry does not support the GB package manager"
        warn "We currently only support the Godep and Glide package managers for go apps"
        warn "For support please file an issue: https://github.com/cloudfoundry/go-buildpack/issues"
        warn ""
        exit 1
    ;;
esac

echo -e "---\ndefault_process_types:\n  web: $(basename $name)" >> /tmp/buildpack-release-step.yml

if test ! -z "${src}" -a "${src}" != "${build}" -a -e "${src}/Procfile"
then
  mv -t "${build}" "${src}/Procfile"
fi

if ! test -e $build/Procfile && test -n "${name}"
then
  echo -e "web: $(basename $name)" >> $build/Procfile
fi

cd $build
mkdir -p $build/.profile.d
echo 'PATH=$PATH:$HOME/bin' > $build/.profile.d/go.sh

if test "${GO_INSTALL_TOOLS_IN_IMAGE}" = "true"
then
    start "Copying go tool chain to \$GOROOT=\$HOME/.heroku/go"
        mkdir -p "${build}/.heroku/go"
        cp -a "${GOROOT}/"* "${build}/.heroku/go"
        echo 'export GOROOT=$HOME/.heroku/go' > "${build}/.profile.d/goroot.sh"
        echo 'PATH=$PATH:$GOROOT/bin' >> "${build}/.profile.d/goroot.sh"
    finished
    step "Copying ${TOOL} binary"
    cp $(which ${TOOL}) "${build}/bin"
fi

if test "${GO_SETUP_GOPATH_IN_IMAGE}" = "true"
then
    start "Cleaning up \$GOPATH/pkg"
        rm -rf $GOPATH/pkg
    finished
    echo 'export GOPATH=$HOME' > "${build}/.profile.d/zzgopath.sh"  #Try to make sure it's down in towards the end
    echo 'cd $GOPATH/src/'${name} >> "${build}/.profile.d/zzgopath.sh" # because of this
fi
